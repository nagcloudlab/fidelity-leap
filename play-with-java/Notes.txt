


style of programming
-------------------------


1. imperative programming

    -> solving problems by giving step by step instructions to the computer
      on how to achieve a certain task.

      intention & implementation mixed together

2. declarative  programming

    -> solving problems by specifying what the desired outcome is,
      without explicitly stating how to achieve it.

      intention & implementation separated

      how to do declarative programming in java?
      => by primitive | object params


-----------------------------------------------------------

data-structure(s)
-------------------------

-> memory-layout of data to do CRUDSS operations ( Algithems ) efficiently

    C  R  U  D  S  S
    ---------------
    Create
    Read
    Update
    Delete
    Search
    Sort

 -----------------------------------------------------------




collection(s) aka data-structure(s)
------------------------------------

collection-framework
--------------------

decision-tree to choose collection
------------------------------------

1. List
    - index based
    - ordered
    - allows duplicates
2. Set
    - no index
    - unordered
    - no duplicates
3. Map
    - user-indefined key-value pairs

-------------------------------------

top-level: interfaces ( abstraction )
mid-level: abstract-classes ( partial-implementation )
bottom-level: classes aka implementations

-------------------------------------
top-level interfaces
-------------------------

1. Collection extends Iterable
    - List
    - Set
2. Map


-------------------------------------
implementations
-------------------------------------

1.List
    - Vector ( dynamic-array, synchronized ( thread-safe ) ) - legacy
    - ArrayList ( dynamic-array, non-synchronized ( not thread-safe ) )
    - LinkedList ( doubly-linked-list )
2.Set
    - HashSet ( hash-table based, unordered )
    - LinkedHashSet ( hash-table + linked-list based, insertion-ordered )
    - TreeSet ( red-black-tree based, sorted-order )
3.Map
    - HashMap ( hash-table based, unordered )
    - LinkedHashMap ( hash-table + linked-list based, insertion-ordered )
    - TreeMap ( red-black-tree based, sorted-order )
4. Others
     - Stack extends Vector - legacy - LIFO
     - Queue ( interface )
         - LinkedList implements Queue - FIFO
         - PriorityQueue implements Queue - priority-based-order
     - Deque ( interface ) - double-ended-queue
         - ArrayDeque implements Deque - dynamic-array based
         - LinkedList implements Deque - doubly-linked-list based



-----------------------------------

 - process vs thread

 process
    ---------------
        -> each has its own memory-space
        -> independent execution
        -> inter-process-communication ( IPC ) is expensive
    ---------------
 thread
    ---------------
        -> shares memory-space with other threads of the same process
        -> lightweight
        -> inter-thread-communication is cheap
    ---------------



-------------------------------------------
java 1.5 new features
-------------------------------------------

1. generics
    -> type-safety at compile-time
2. enhanced-for-loop
    -> simplified iteration over collections and arrays
3. autoboxing and unboxing
    -> automatic conversion between primitive types and their corresponding wrapper classes
4. varargs
    -> method parameter that accepts variable number of arguments
5. static-import
    -> import static members of a class so that they can be used without class qualification
6. concurrency utilities
    -> high-level concurrency constructs in java.util.concurrent package
7. annotations
    -> metadata to provide information about the program
8. enum types
    -> special data type to define a set of named constants
9. java.util.concurrent package
    -> high-level concurrency utilities for multi-threaded programming


java 1.8 -> 8
-------------------------------------------

1. lambda expressions
    -> enable functional programming by allowing functions to be treated as first-class citizens
2. functional interfaces
    -> interfaces with a single abstract method, used as the target for lambda expressions
3. method references
    -> shorthand notation of a lambda expression to call a method
4. default methods in interfaces
    -> allow interfaces to have method implementations
5. streams API
    -> facilitate functional-style operations on collections of objects
6. java.time package
    -> new date and time API for better handling of date and time operations
7. optional class
    -> container object which may or may not contain a non-null value
8. repeating annotations
    -> allow the same annotation to be applied multiple times to a single element
9. type annotations


java 17
-------------------------------------------

1. sealed classes and interfaces
    -> restrict which other classes or interfaces can extend or implement them
2. pattern matching for instanceof
    -> simplifies type checks and casts
3. records



